---
title: นิพจน์ข้อจำกัดและข้อจำกัดของตารางในแบบจำลองการจัดโครงแบบผลิตภัณฑ์
description: หัวข้อนี้อธิบายการใช้ข้อจำกัดนิพจน์และข้อจำกัดตาราง  ข้อจำกัดถูกใช้ในการควบคุมค่าแอททริบิวต์ที่คุณสามารถเลือกได้เมื่อคุณจัดโครงแบบผลิตภัณฑ์สำหรับใบสั่งขาย ใบเสนอราคาขาย ใบสั่งซื้อ หรือใบสั่งผลิต คุณสามารถใช้ข้อจำกัดนิพจน์หรือข้อจำกัดตาราง ขึ้นอยู่กับวิธีที่คุณต้องการสร้างข้อจำกัด
author: cvocph
manager: tfehr
ms.date: 06/20/2017
ms.topic: article
ms.prod: ''
ms.service: dynamics-ax-applications
ms.technology: ''
ms.search.form: PCGlobalTableConstraintEdit, PCProductConfigurationModelDetails, PCTableConstraintAttachAttributeTree, PCTableConstraintDefinition
audience: Application User
ms.reviewer: kamaybac
ms.search.scope: Core, Operations
ms.custom: 53111
ms.assetid: 5c12b1f2-eb89-4648-a755-de412f2eadd6
ms.search.region: Global
ms.search.industry: Manufacturing
ms.author: kamaybac
ms.search.validFrom: 2016-02-28
ms.dyn365.ops.version: AX 7.0.0
ms.openlocfilehash: be9d9ae48d21db077928ba7bd5615fea47ea5181
ms.sourcegitcommit: 199848e78df5cb7c439b001bdbe1ece963593cdb
ms.translationtype: HT
ms.contentlocale: th-TH
ms.lasthandoff: 10/13/2020
ms.locfileid: "4438681"
---
# <a name="expression-constraints-and-table-constraints-in-product-configuration-models"></a>นิพจน์ข้อจำกัดและข้อจำกัดของตารางในแบบจำลองการจัดโครงแบบผลิตภัณฑ์

[!include [banner](../includes/banner.md)]

หัวข้อนี้อธิบายการใช้ข้อจำกัดนิพจน์และข้อจำกัดตาราง  ข้อจำกัดถูกใช้ในการควบคุมค่าแอททริบิวต์ที่คุณสามารถเลือกได้เมื่อคุณจัดโครงแบบผลิตภัณฑ์สำหรับใบสั่งขาย ใบเสนอราคาขาย ใบสั่งซื้อ หรือใบสั่งผลิต คุณสามารถใช้ข้อจำกัดนิพจน์หรือข้อจำกัดตาราง ขึ้นอยู่กับวิธีที่คุณต้องการสร้างข้อจำกัด 

ข้อจำกัดถูกใช้ในการควบคุมค่าแอททริบิวต์ที่คุณสามารถเลือกได้เมื่อคุณจัดโครงแบบผลิตภัณฑ์สำหรับใบสั่งขาย ใบเสนอราคาขาย ใบสั่งซื้อ หรือใบสั่งผลิต คุณสามารถใช้นิพจน์ข้อจำกัดหรือข้อจำกัดตาราง ขึ้นอยู่กับว่าคุณต้องการสร้างข้อจำกัดอย่างไร

## <a name="what-are-expression-constraints"></a>ข้อจำกัดนิพจน์คืออะไร
ข้อจำกัดนิพจน์จะถูกกำหนดลักษณะตามนิพจน์ที่ใช้ฟังก์ชันและตัวดำเนินการคณิตศาสตร์และบูลีน มีการบันทึกข้อจำกัดนิพจน์สำหรับส่วนประกอบเฉพาะในแบบจำลองการจัดโครงแบบผลิตภัณฑ์ ไม่สามารถนำมาใช้ใหม่หรือใช้ร่วมกับส่วนประกอบอื่น อย่างไรก็ตาม ข้อจำกัดนิพจน์สำหรับส่วนประกอบสามารถอ้างอิงแอททริบิวต์ของส่วนประกอบย่อยของส่วนประกอบ

## <a name="what-are-table-constraints"></a>ข้อจำกัดของตารางคืออะไร
ข้อจำกัดตารางแสดงชุดของค่าที่อนุญาตสำหรับแอททริบิวต์เมื่อคุณจัดโครงแบบผลิตภัณฑ์ สามารถใช้คำนิยามข้อจำกัดตารางโดยทั่วไป เมื่อคุณสร้างข้อจำกัดตารางสำหรับองค์ประกอบในแบบจำลองการจัดโครงแบบผลิตภัณฑ์ คุณเลือกคำนิยามข้อจำกัดตาราง เพื่อสร้างชุดข้อมูลที่ได้รับอนุญาต เพิ่มแอททริบิวต์ของชนิดเฉพาะกับส่วนประกอบต่าง ๆ แอททริบิวต์แต่ละชนิดมีค่าระบุไว้

### <a name="example-of-a-table-constraint"></a>ตัวอย่างข้อจำกัดตาราง

ตัวอย่างนี้แสดงว่าคุณสามารถจำกัดการตั้งค่าคอนฟิกของลำโพงเพื่อเสร็จสิ้นการ cabinet เฉพาะและ fronts ตารางแรกแสดง cabinet เสร็จสิ้นและ fronts ที่พร้อมใช้งานสำหรับการตั้งค่าคอนฟิกโดยทั่วไป ค่ากำหนดไว้สำหรับชนิดของแอททริบิวต์ **Cabinet เสร็จสิ้น** และ **grill หน้า**

| ชนิดของแอททริบิวต์ | ค่า                      |
|----------------|-----------------------------|
| cabinet เสร็จสิ้น | สีดำ ไม้โอ้ค Rosewood สีขาว |
| Grill หน้า    | สีดำ โลหะ สีขาว         |

ตารางถัดไปแสดงชุดข้อมูลที่กำหนดโดยข้อจำกัดตาราง **สีและเสร็จสิ้น** โดยการใช้ข้อจำกัดตารางนี้ คุณสามารถตั้งค่าคอนฟิกลำโพงที่มีไม้โอ้คเสร็จสิ้น และ grill เป็นสีดำ Rosewood เสร็จสิ้น และ grill เป็นสีขาว และอื่น ๆ

| เสร็จสิ้น         | Grill                       |
|----------------|-----------------------------|
| ไม้โอ้ค            | สีดำ                       |
| โรสวูด       | สีขาว                       |
| สีขาว          | สีดำ                       |
| สีขาว          | สีขาว                       |
| สีดำ          | สีดำ                       |
| สีดำ          | โลหะ                       | 

คุณสามารถสร้างข้อจำกัดตารางการที่กำหนดโดยระบบและโดยผู้ใช้ ดูข้อมูลเพิ่มเติม [ข้อจำกัดตารางที่ระบบกำหนดและกำหนดผู้ใช้](system-defined-user-defined-table-constraints.md)

## <a name="what-syntax-should-be-used-to-write-constraints"></a>ไวยากรณ์ใดควรใช้ในการบันทึกข้อจำกัด
คุณต้องใช้ไวยากรณ์ Optimization Modeling Language (OML) เมื่อคุณเขียนข้อจำกัด ระบบใช้โปรแกรมแก้ปัญหาข้อจำกัด Microsoft Solver Foundation เพื่อแก้ไขข้อจำกัด

## <a name="should-i-use-table-constraints-or-expression-constraints"></a>ฉันควรใช้ข้อจำกัดตารางหรือข้อจำกัดนิพจน์
คุณสามารถใช้ทั้งนิพจน์ข้อจำกัดหรือข้อจำกัดตาราง ขึ้นอยู่กับว่าคุณต้องการสร้างข้อจำกัดอย่างไร คุณสร้างข้อจำกัดตารางเป็นเมทริกซ์ ในขณะที่ข้อจำกัดนิพจน์เป็นคำสั่งแต่ละรายการ เมื่อคุณจัดโครงแบบผลิตภัณฑ์ ไม่สำคัญว่าจะใช้ชนิดของข้อจำกัดใด ตัวอย่างต่อไปนี้จะแสดงความแตกต่างของสองวิธี  

เมื่อคุณจัดโครงแบบผลิตภัณฑ์โดยใช้การตั้งค่าข้อจำกัดต่อไปนี้ ชุดข้อมูลเหล่านี้ได้รับอนุญาต:

-   ผลิตภัณฑ์สีดำ และขนาด 30 หรือ 50
-   ผลิตภัณฑ์สีแดง และขนาด 20

### <a name="table-constraint-setup"></a>การตั้งค่าข้อจำกัดตาราง

| สี | ขนาด |
|-------|------|
| สีดำ | 30   |
| สีดำ | 50   |
| สีแดง   | 20   |

### <a name="expression-constraint-setup"></a>การตั้งค่าข้อจำกัดนิพจน์

(สี == "ดำ" & (ขนาด == "30" | ขนาด == "50")) | (สี == "แดง" & ขนาด = "20")

## <a name="should-i-use-operators-or-infix-notation-when-i-write-expression-constraints"></a>ฉันควรใช้ตัวดำเนินการ หรือ infix สัญลักษณ์เมื่อฉันเขียนข้อจำกัดนิพจน์หรือไม่
คุณสามารถเขียนข้อจำกัดนิพจน์ โดยใช้ทั้งตัวดำเนินการคำนำหน้าที่พร้อมใช้งาน หรือ สัญลักษณ์ infix สำหรับการดำเนินการ **Min**, **Max** และ **Abs** คุณไม่สามารถใช้สัญลักษณ์ infix ได้ ตัวดำเนินการเหล่านี้จะรวมเป็นตัวดำเนินการมาตรฐานในภาษาการเขียนโปรแกรมส่วนใหญ่

## <a name="what-operators-and-infix-notation-can-i-use-when-i-write-expression-constraints"></a>ตัวดำเนินการและสัญลักษณ์ infix ใดที่ฉันสามารถใช้เขียนข้อจำกัดนิพจน์
ตารางต่อไปนี้แสดงรายการตัวดำเนินการและสัญลักษณ์ infix ที่คุณสามารถใช้เมื่อคุณเขียนข้อจำกัดนิพจน์สำหรับส่วนประกอบในแบบจำลองการตั้งค่าคอนฟิกผลิตภัณฑ์ ในตัวอย่างในตารางแรกนี้ แสดงวิธีการเขียนนิพจน์โดยใช้สัญลักษณ์ infix หรือตัวดำเนินการ

<table>
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead>
<tr class="header">
<th>ผู้ปฏิบัติงาน</th>
<th>คำอธิบาย</th>
<th>ไวยากรณ์</th>
<th>ตัวอย่างเช่น</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>บ่งชี้</td>
<td>จะเป็นจริงหากเงื่อนไขแรกเป็นเท็จ เงื่อนไขที่สองเป็นจริง หรือทั้งสองอย่าง</td>
<td>บ่งชี้[a, b], infix: a -: b</td>
<td><ul>
<li><strong>ตัวดำเนินการ:</strong> บ่งชี้[x != 0, y &gt;= 0]</li>
<li><strong>Infix สัญลักษณ์:</strong> x != 0 -: y &gt;= 0</li>
</ul></td>
</tr>
<tr class="even">
<td>และ</td>
<td>จะเป็นจริงหากเงื่อนไขทั้งหมดเป็นจริง ถ้าหมายเลขของเงื่อนไขเป็น 0 (ศูนย์) จะให้ผล <strong>จริง</strong></td>
<td>และ[args], infix: a &amp; b &amp; ... &amp; z</td>
<td><ul>
<li><strong>ตัวดำเนินการ:</strong> และ[x == 2, y &lt;= 2]</li>
<li><strong>สัญลักษณ์ Infix:</strong> x == 2 &amp; y &lt;= 2</li>
</ul></td>
</tr>
<tr class="odd">
<td>หรือ</td>
<td>จะเป็นจริงหากเงื่อนไขใดๆ เป็นจริง ถ้าหมายเลขของเงื่อนไขเป็น 0 (ศูนย์) จะให้ผล <strong>เท็จ</strong></td>
<td>หรือ[args], infix: a | b | ... | z</td>
<td><ul>
<li><strong>ตัวดำเนินการ:</strong> หรือ[x == 2, y &lt;= 2]</li>
<li><strong>สัญลักษณ์ Infix:</strong> x == 2 | y &lt;= 2</li>
</ul></td>
</tr>
<tr class="even">
<td>บวก</td>
<td>คือผลรวมเงื่อนไข ถ้าหมายเลขของเงื่อนไขเป็น 0 (ศูนย์) จะให้ผล <strong>0</strong></td>
<td>บวก[args], infix: a + b + ... + z</td>
<td><ul>
<li><strong>ตัวดำเนินการ:</strong> บวก[x, y, 2] == z</li>
<li><strong>สัญลักษณ์ Infix:</strong> x + y + 2 == z</li>
</ul></td>
</tr>
<tr class="odd">
<td>ลบ</td>
<td>ปฏิเสธอาร์กิวเมนต์ ต้องมีเพียงหนึ่งเงื่อนไขที่ตรงทุกประการ</td>
<td>ลบ[expr], infix: -expr</td>
<td><ul>
<li><strong>ตัวดำเนินการ:</strong> ลบ[x] == y</li>
<li><strong>สัญลักษณ์ Infix:</strong>-x == y</li>
</ul></td>
</tr>
<tr class="even">
<td>Abs</td>
<td>นำค่าสัมบูรณ์ของเงื่อนไข ต้องมีเพียงหนึ่งเงื่อนไขที่ตรงทุกประการ</td>
<td>Abs[expr]</td>
<td><strong>ตัวดำเนินการ:</strong> Abs[x]</td>
</tr>
<tr class="odd">
<td>เวลา</td>
<td>นำผลิตภัณฑ์ของเงื่อนไข ถ้าหมายเลขของเงื่อนไขเป็น 0 (ศูนย์) จะให้ผล <strong>1</strong></td>
<td>คูณ[args], infix: a * b * ... * z</td>
<td><ul>
<li><strong>ตัวดำเนินการ:</strong> คูณ[x, y, 2] == z</li>
<li><strong>สัญลักษณ์ Infix:</strong> x * y * 2 == z</li>
</ul></td>
</tr>
<tr class="even">
<td>กำลัง</td>
<td>นำเลขชี้กำลัง มีเลขยกกำลังจากขวาไปซ้าย (หรืออีกนัยหนึ่ง นั่น&#39;คือการเชื่อมโยงสิทธิ์) ดังนั้น <strong>กำลัง[a, b, c]</strong> เทียบเท่ากับ <strong>กำลัง[a, กำลัง[b, c]]</strong> <strong>กำลัง</strong> สามารถใช้ได้เมื่อการยกกำลังมีค่าเป็นค่าบวกเท่านั้น</td>
<td>กำลัง[args], infix: a ^ b ^ ... ^ z</td>
<td><ul>
<li><strong>ตัวดำเนินการ:</strong> กำลัง[x, 2] == y</li>
<li><strong>สัญลักษณ์ Infix:</strong> x ^ 2 == y</li>
</ul></td>
</tr>
<tr class="odd">
<td>สูงสุด</td>
<td>ก่อให้เกิดเงื่อนไขใหญ่ที่สุด ถ้าหมายเลขของเงื่อนไขเป็น 0 (ศูนย์) จะให้ผล <strong>อนันต์</strong></td>
<td>ค่าสูงสุด[args]</td>
<td><strong>ตัวดำเนินการ:</strong> ค่าสูงสุด[x, y, 2] == z</td>
</tr>
<tr class="even">
<td>นาที</td>
<td>ก่อให้เกิดเงื่อนไขเล็กที่สุด ถ้าหมายเลขของเงื่อนไขเป็น 0 (ศูนย์) จะให้ผล <strong>อนันต์</strong></td>
<td>ค่าต่ำสุด[args]</td>
<td><strong>ตัวดำเนินการ:</strong> ค่าต่ำสุด[x, y, 2] == z</td>
</tr>
<tr class="odd">
<td>ไม่ใช่</td>
<td>ก่อให้เกิดตัวผกผันทางตรรกะของเงื่อนไข ต้องมีเพียงหนึ่งเงื่อนไขที่ตรงทุกประการ</td>
<td>ไม่ใช่[expr], infix: !expr</td>
<td><ul>
<li><strong>ตัวดำเนินการ:</strong> ไม่ใช่[x] &amp;  ไม่ใช่[y == 3]</li>
<li><strong>สัญลักษณ์ Infix:</strong> !x!(y == 3)</li>
</ul></td>
</tr>
</tbody>
</table>

ตัวอย่างในตารางถัดไปแสดงวิธีการเขียนสัญลักษณ์ Infix


|  Infix สัญลักษณ์   |                                          คำอธิบาย                                          |
|-------------------|-----------------------------------------------------------------------------------------------|
|     x + y + z     |                                           การเพิ่มขึ้น                                            |
|    x \* y \* z    |                                        คูณ                                         |
|       x - y       | การลบเลขฐานสองถูกแปลเหมือนกับการเพิ่มเลขฐานสองเมื่อมีวินาทีที่ปฏิเสธ |
|     x ^ y ^ z     |                          การยกกำลังที่มีทิศทางจากขวาไปซ้าย                          |
|        !x         |                                          ไม่ใช่บูลีน                                          |
|      x -: y       |                                      การส่อความบูลีน                                      |
|         x         |                                               y                                               |
|     x & y & z     |                                          บูลีนและ                                          |
|    x == y == z    |                                           ความเท่าเทียม                                            |
|    x != y != z    |                                           ชัดเจน                                            |
|  x &lt; y &lt; z  |                                           น้อยกว่า                                           |
|  x &gt; y &gt; z  |                                         มากกว่า                                          |
| x &lt;= y &lt;= z |                                     น้อยกว่าหรือเท่ากับ                                     |
| x &gt;= y &gt;= z |                                   มากกว่าหรือเท่ากับ                                    |
|        (x)        |                           วงเล็บแทนที่ความสำคัญเริ่มต้น                            |

## <a name="why-arent-my-expression-constraints-validated-correctly"></a>เหตุใดข้อจำกัดนิพจน์ของฉันจึงถูกตรวจสอบไม่ถูกต้อง
คุณไม่สามารถใช้คำสำคัญที่สำรองไว้เป็นชื่อโปรแกรมแก้ปัญหาแอททริบิวต์ ส่วนประกอบ หรือส่วนประกอบย่อยในแบบจำลองการตั้งค่าคอนฟิกผลิตภัณฑ์  นี่คือรายการของคำสำคัญที่สงวนไว้ซึ่งคุณไม่สามารถใช้ได้:

-   เพดานเงิน
-   องค์ประกอบ
-   เท่ากับ
-   ขั้นต่ำสุด
-   ถ้า
-   น้อยกว่า
-   มากกว่า
-   บ่งชี้
-   ล็อก
-   สูงสุด
-   นาที
-   ลบ
-   บวก
-   กำลัง
-   เวลา
-   ช่อง
-   รุ่น
-   การตัดสินใจ
-   เป้าหมาย


<a name="additional-resources"></a>แหล่งข้อมูลเพิ่มเติม
--------

[สร้างข้อจำกัดนิพจน์](tasks/add-expression-constraint-product-configuration-model.md)

[เพิ่มการคำนวณไปยังแบบจำลองการจัดโครงแบบผลิตภัณฑ์](tasks/add-calculation-product-configuration-model.md)



